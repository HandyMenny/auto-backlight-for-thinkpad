<#@ template debug="true" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<# int i = 0; #>
<#
var entries = new List<Entry>{
    new Entry{ type="double", Name="Timeout", def="60", min="1", max="double.PositiveInfinity", unit="s", help="Keyboard backlight timeout after user inactivity" },
};
#>
/*
 * Copyright 2019 Parth Patel
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;

namespace Auto_Keyboard_Backlight
{
    public partial class Settings : INotifyPropertyChanged
    {
    
        #region Data

<# i = 0;
foreach (var entry in entries) { #>
        public <#=entry.type#> <#=entry.Name#> { get => _raw.<#=entry.Name#>; set => _Set(ref _raw.<#=entry.Name#>, value, Meta.<#=entry.Name#>, <#=i#>, nameof(<#=entry.Name#>)); }
<# i++; }#>

        #endregion Data

        #region Internal

        private void _Set<T>(ref T item, T value, Metadata<T> meta, int index, string name)
        {
            bool equatable = typeof(T).GetInterface("IEquatable") != null;
            if (equatable)
            {
                bool comparable = typeof(T).GetInterface("IComparable") != null;
                if (comparable) 
                {
                    bool requested = !((dynamic)meta.Min).Equals(default(T)) || !((dynamic)meta.Max).Equals(default(T));
                    if (requested)
                    {
                        if (((dynamic)value).CompareTo(meta.Min) < 0) value = meta.Min;
                        if (((dynamic)value).CompareTo(meta.Max) > 0) value = meta.Max;
                    }
                }
            }
            bool r = true;
            if (equatable)
            {
                if (((dynamic)value).Equals(item)) r = false;
            }
            item = value;
            if (r) RaisePropertyChanged(name);
        }
        [Serializable]
        public struct Raw
        {
<# foreach (var entry in entries) { #>
            public <#=entry.type#> <#=entry.Name #>;
<# } #>
        }
        private Raw _raw;

        public int ToIndex(string key)
        {
            switch (key) {
<# i = 0;
foreach (var entry in entries) { #>
                case nameof(<#=entry.Name#>): { return <#=i#>; }
<# i++; } #>
                default: { throw new ArgumentOutOfRangeException(); }
            }
        }
        public string ToName(int index)
        {
            switch (index) {
<# i = 0;
foreach (var entry in entries) { #>
                case <#=i#>: { return nameof(<#=entry.Name#>); }
<# i++; } #>
                default: { throw new ArgumentOutOfRangeException(); }
            }
        }
        public Settings(Settings s) : this() 
        {
            _raw = s._raw;
        }
        public Settings()
        {
            Meta = new Metadata(
<# i = 0; foreach (var entry in entries) { #>
                                <#=entry.Name#>:new Metadata<<#=entry.type#>>(def:<#=entry.def#>, min:<#=entry.min#>, max:<#=entry.max#>, unit:"<#=entry.unit#>", help:"<#=entry.help#>")<# if (i < entries.Count - 1) { #>, <# } #>

<# i++; } #>
                                );
<# foreach (var entry in entries) { #>
            _raw.<#=entry.Name#> = Meta.<#=entry.Name#>.Def;
<# } #>
            
            List = new ListView(this);
            Dictionary = new DictionaryView(this);
            PropertyChanged += (sender, e) => {
                string name = e.PropertyName;
                Dictionary.RaisePropertyChanged(name.ToString());
                List.RaisePropertyChanged(ToIndex(name).ToString());
            };
            Update();
        }
        public event PropertyChangedEventHandler PropertyChanged;
        public void RaisePropertyChanged(string prop) => PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(prop));
        public void Update() {
<# foreach (var entry in entries) { #>
            RaisePropertyChanged(nameof(<#=entry.Name#>));
<# } #>
        }

        #endregion Internal

        #region DataViews

        public class ListView : IReadOnlyList<object>, INotifyPropertyChanged
        {
            public ListView(Settings settings)
            {
                s = settings;
            }
            public int Count => <#=entries.Count#>;
            public object this[int index]
            {
                get
                {
                    switch (index) {
<# i = 0;
foreach (var entry in entries) { #>
                        case <#=i#>: { return s.<#=entry.Name#>; }
<# i++; } #>
                        default: { throw new IndexOutOfRangeException(); }
                    }
                }
                set
                {
                    switch (index) {
<# i = 0;
foreach (var entry in entries) { #>
                        case <#=i#>: { s.<#=entry.Name#> = (<#=entry.type#>)value; return; }
<# i++; } #>
                        default: { throw new IndexOutOfRangeException(); }
                    }
                }
            }
            public IEnumerator<object> GetEnumerator()
            {
<# foreach (var entry in entries) { #>
                yield return s.<#=entry.Name#>;
<# } #>
            }
            IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

            public event PropertyChangedEventHandler PropertyChanged;
            public void RaisePropertyChanged(string prop) => PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(prop));
            
            private readonly Settings s;
        }
        public ListView List { get; }

        public class DictionaryView : IReadOnlyDictionary<string, object>, INotifyPropertyChanged
        {
            public DictionaryView(Settings settings)
            {
                s = settings;
            }
            public int Count => <#=entries.Count#>;
            public IEnumerable<string> Keys
            {
                get
                {
<# foreach (var entry in entries) { #>
                    yield return nameof(s.<#=entry.Name#>);
<# } #>
                }
            }
            public IEnumerable<object> Values
            {
                get
                {
<# foreach (var entry in entries) { #>
                    yield return s.<#=entry.Name#>;
<# } #>
                }
            }
            public object this[string key]
            {
                get
                {
                    switch (key) {
<# foreach (var entry in entries) { #>
                        case nameof(s.<#=entry.Name#>): { return s.<#=entry.Name#>; }
<# } #>
                        default: { throw new IndexOutOfRangeException(); }
                    }
                }
                set
                {
                    switch (key) {
<# foreach (var entry in entries) { #>
                        case nameof(s.<#=entry.Name#>): { s.<#=entry.Name#> = (<#=entry.type#>)value; return; }
<# } #>
                        default: { throw new IndexOutOfRangeException(); }
                    }
                }
            }
            public bool ContainsKey(string key)
            {
                foreach (string k in Keys)
                    if (key == k) return true;
                return false;
            }
            public bool TryGetValue(string key, out object value)
            {
                if (ContainsKey(key))
                {
                    value = this[key];
                    return true;
                }
                else
                {
                    value = null;
                    return false;
                }
            }
            public IEnumerator<KeyValuePair<string, object>> GetEnumerator()
            {
<# foreach (var entry in entries) { #>
                yield return new KeyValuePair<string, object>(nameof(s.<#=entry.Name#>), s.<#=entry.Name#>);
<# } #>
            }
            IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

            public event PropertyChangedEventHandler PropertyChanged;
            public void RaisePropertyChanged(string prop) => PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(prop));
            
            private readonly Settings s;
        }
        public DictionaryView Dictionary { get; }

        #endregion DataViews

        #region Metadata

        public struct Metadata<T>
        {
            public Metadata(T def, T min, T max, string unit, string help)
            {
                Def = def;
                Min = min;
                Max = max;
                Unit = unit;
                Help = help;
            }
            public T Def { get; }
            public T Min { get; }
            public T Max { get; }
            public string Unit { get; }
            public string Help { get; }
        }

        public class Metadata
        {
            public Metadata(<# i = 0; foreach (var entry in entries) { #>Metadata<<#=entry.type#>> <#=entry.Name#><# if (i < entries.Count - 1) { #>, <# } #><# i++; } #>)
            {
<# foreach (var entry in entries) { #>
                this.<#=entry.Name#> = <#=entry.Name#>;
<# } #>
                
                List = new ListView(this);
                Dictionary = new DictionaryView(this);
            }
<# foreach (var entry in entries) { #>
            public Metadata<<#=entry.type#>> <#=entry.Name#> { get; }
<# } #>

            #region MetadataViews
            
            public class ListView : IReadOnlyList<object>
            {
                public ListView(Metadata metadata)
                {
                    m = metadata;
                }
                public int Count => <#=entries.Count#>;
                public object this[int index]
                {
                    get
                    {
                        switch (index) {
<# i = 0;
foreach (var entry in entries) { #>
                            case <#=i#>: { return m.<#=entry.Name#>; }
<# i++; } #>
                            default: { throw new IndexOutOfRangeException(); }
                        }
                    }
                }
                public IEnumerator<object> GetEnumerator()
                {
<# foreach (var entry in entries) { #>
                    yield return m.<#=entry.Name#>;
<# } #>
                }
                IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

                private readonly Metadata m;
            }
            public ListView List { get; }

            public class DictionaryView : IReadOnlyDictionary<string, object>
            {
                public DictionaryView(Metadata metadata)
                {
                    m = metadata;
                }
                public int Count => <#=entries.Count#>;
                public IEnumerable<string> Keys
                {
                    get
                    {
<# foreach (var entry in entries) { #>
                        yield return nameof(m.<#=entry.Name#>);
<# } #>
                    }
                }
                public IEnumerable<object> Values
                {
                    get
                    {
<# foreach (var entry in entries) { #>
                        yield return m.<#=entry.Name#>;
<# } #>
                    }
                }
                public object this[string key]
                {
                    get
                    {
                        switch (key) {
<# foreach (var entry in entries) { #>
                            case nameof(m.<#=entry.Name#>): { return m.<#=entry.Name#>; }
<# } #>
                            default: { throw new IndexOutOfRangeException(); }
                        }
                    }
                }
                public bool ContainsKey(string key)
                {
                    foreach (string k in Keys)
                        if (key == k) return true;
                    return false;
                }
                public bool TryGetValue(string key, out object value)
                {
                    if (ContainsKey(key))
                    {
                        value = this[key];
                        return true;
                    }
                    else
                    {
                        value = null;
                        return false;
                    }
                }
                public IEnumerator<KeyValuePair<string, object>> GetEnumerator()
                {
<# foreach (var entry in entries) { #>
                    yield return new KeyValuePair<string, object>(nameof(m.<#=entry.Name#>), m.<#=entry.Name#>);
<# } #>
                }
                IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

                private readonly Metadata m;
            }
            public DictionaryView Dictionary { get; }
            
            #endregion MetadataViews

        }
        public Metadata Meta { get; }

        #endregion Metadata

    }
}

<#+
public struct Entry
{
    public string type;
    public string Name;
    public string def;
    public string min;
    public string max;
    public string unit;
    public string help;
};
#>